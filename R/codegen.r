
# Low level functions in spotifyr are generated by parsing the high level definitions
# https://developer.spotify.com/web-api/endpoint-reference/ as it is less bug prone.
# This file contains the code generation functions

method_ix <- 1
endpoint_ix <- 2
usage_ix <- 3
returns_ix <- 4

pat_id <- "\\{id\\}"
pat_ids <- "\\{ids\\}"
pat_type <- "\\{type\\}"
pat_userid <- "\\{user_id\\}"
pat_playlistid <- "\\{playlist_id\\}"
pat_ownerid <- "\\{owner_id\\}"


id_id <- "id"
id_ids <- "ids"
id_type <- "type"
id_userid <- "user_id"
id_playlistid <- "playlist_id"
id_ownerid <- "owner_id"

#' preprocess_endpoint_def
#'
#' preprocess_endpoint_def
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @import stringr
preprocess_endpoint_def <- function(api_def) {
  x <- stringr::str_split(api_def, ", ")[[1]]
  x <- stringr::str_trim(x)
  x
}

#' generate_endpoint_url
#'
#' generate_endpoint_url
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @import stringr
generate_endpoint_url <- function(api_def) {
  x <- preprocess_endpoint_def(api_def)
  # /v1/users/{user_id}/playlists/{playlist_id}/tracks
  endpoint_args <- stringr::str_replace_all(x[endpoint_ix], "/v1/", "")
  # slight hack to split after = as in:
  # albums?ids={ids}, Get several albums, albums"
  endpoint_args <- stringr::str_replace_all(endpoint_args, "=", "=/")

  endpoint_args <- stringr::str_split(endpoint_args, "/")[[1]]

  # anything not starting with '{' is a literal string and should be surrended by quotes
  is_id <- function(x) { stringr::str_detect(x, '^\\{') }
  endpoint_args <- ifelse(is_id(endpoint_args), endpoint_args, paste0("\"", endpoint_args, "\""))

  # {id}  ===> retrieve_id(id, id_type)
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_id, "retrieve_id(id, id_type)")
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_ids, "list_ids(ids, id_type)")
  # {type}  ===> check_type(type)
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_type, "check_type(type)")
  # {user_id}  ===> check_type(type)
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_userid, "user_id")
  # {playlist_id}  ===> check_type(type)
  # the full playlist uri may be something like: spotify:user:jmp202:playlist:4yQEwOFAUnH6XqM9QfNkRm
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_playlistid, "retrieve_id(playlist_id, playlist_id_type)")
  # {owner_id}  ===> check_type(type)
  endpoint_args <- stringr::str_replace_all(endpoint_args, pat_ownerid, "owner_id")
  endpoint_args <- paste(endpoint_args, collapse = ', ')
  endpoint_url <- paste0("create_url_endpoint(",endpoint_args,")");
  endpoint_url
}

#' generate_low_level_funcname
#'
#' generate_low_level_funcname
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @param prefix a string, a prefix to use for the low-level function names generated.
#' @import stringr
generate_low_level_funcname <- function(api_def, prefix='i') {
  x <- preprocess_endpoint_def(api_def)
  api_items <- stringr::str_replace_all(x[endpoint_ix], "/v1/", "")
  # GET, /v1/albums/{id}/tracks , Get an album's tracks, tracks*
  func_name <- ""
  if(stringr::str_detect(x[method_ix], 'GET')) func_name <- 'get'
  # endpoint_args
  # 'albums/{id}/tracks'

  str_remove_all <- function(x, pat) { stringr::str_replace_all(x, pat, '')}

  ch <- '='
  api_items <- str_remove_all(api_items, paste0(ch, pat_id ))
  api_items <- str_remove_all(api_items, paste0(ch, pat_ids ))
  api_items <- str_remove_all(api_items, paste0(ch, pat_type ))
  api_items <- str_remove_all(api_items, paste0(ch, pat_userid ))
  api_items <- str_remove_all(api_items, paste0(ch, pat_ownerid ))
  api_items <- str_remove_all(api_items, paste0(ch, pat_playlistid ))
  ch <- '/'
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_id         ), paste0(ch, id_id         ))
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_ids        ), paste0(ch, id_ids        ))
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_type       ), paste0(ch, id_type       ))
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_userid     ), paste0(ch, id_userid     ))
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_ownerid    ), paste0(ch, id_ownerid    ))
  api_items <- stringr::str_replace_all(api_items, paste0(ch, pat_playlistid ), paste0(ch, id_playlistid ))

  api_items <- stringr::str_replace_all(api_items, '\\?', '/')
  api_items <- stringr::str_replace_all(api_items, '=', '/')
  # related-artists
  api_items <- stringr::str_replace_all(api_items, '-', '_')

  func_name <- paste(prefix, func_name, stringr::str_replace_all(api_items, '/', '_') , sep='_')
  func_name
}

#' generate_low_level_api_call
#'
#' generate_low_level_api_call
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @import stringr
generate_low_level_api_call <- function(api_def) {
  endpoint_url <- generate_endpoint_url(api_def)
  # create_url_endpoint("albums", retrieve_id(id, id_type))
  x <- preprocess_endpoint_def(api_def)

  method_call <- 'spot_get'
  if(stringr::str_detect(x[method_ix], 'GET')) method_call <- 'spot_get'
  if(stringr::str_detect(x[method_ix], 'PUT')) method_call <- 'spot_put'
  if(stringr::str_detect(x[method_ix], 'POST')) method_call <- 'spot_post'
  if(stringr::str_detect(x[method_ix], 'DELETE')) method_call <- 'spot_delete'
  api_call <- paste0(method_call,'(spot_ctx, ',endpoint_url,', query=query)')
  # spot_get(spot_ctx, create_url_endpoint("artists", retrieve_id(id, id_type), "related-artists"))
  api_call
}


#' generate_low_level
#'
#' generate_low_level
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @param exported boolean, should the generated function be exported by the package
#' @import stringr
generate_low_level <- function(api_def, exported=FALSE) {
  endpoint_url <- generate_endpoint_url(api_def)
  # create_url_endpoint("albums", retrieve_id(id, id_type))
  x <- preprocess_endpoint_def(api_def)

  func_args <- 'spot_ctx'
  if(stringr::str_detect(x[endpoint_ix], pat_id))  func_args <- c(func_args, id_id, 'id_type')
  if(stringr::str_detect(x[endpoint_ix], pat_ids))  func_args <- c(func_args, id_ids, 'id_type')
  if(stringr::str_detect(x[endpoint_ix], pat_type))  func_args <- c(func_args, id_type)
  if(stringr::str_detect(x[endpoint_ix], pat_userid))  func_args <- c(func_args, id_userid)
  if(stringr::str_detect(x[endpoint_ix], pat_playlistid))  func_args <- c(func_args, id_playlistid, 'id_type')
  if(stringr::str_detect(x[endpoint_ix], pat_ownerid))  func_args <- c(func_args, id_ownerid)

  func_args <- c(func_args, "query=NULL") # always append a query parameter

  api_call <- generate_low_level_api_call(api_def)

  func_name <- generate_low_level_funcname(api_def)

  wrapper_lines <- paste0(func_name, ' <- function(', paste(func_args, collapse=', '), ') {')
  if(exported) {
    docco <- rep(c
    (
      paste0("#' ",func_name),
      "#' "
    ), 2)
    # moreve default arg values
    func_arg_names <- stringr::str_replace_all(func_args, '=.*', '') 
    paramsdoc <- paste( "#' @param ", func_arg_names, func_arg_names, sep=' ')    
    docco <- c(docco, paramsdoc)
    docco <- c(docco, "#' @return a list")
    docco <- c(docco, "#' @export")
    wrapper_lines <- c( docco, wrapper_lines)
  }
  wrapper_lines <- c( wrapper_lines, paste0('  ', api_call, ' %>% json_parse') )
  wrapper_lines <- c( wrapper_lines, '}' )
  wrapper_lines <- c( wrapper_lines, '' )
  wrapper_lines

}

#' generate_docstring
#'
#' generate_docstring
#'
#' @param api_def a CSV string of the web api as per the web site, e.g. '# GET, /v1/me/albums/contains?ids={ids}'
#' @import stringr
generate_docstring <- function(api_def) {
  x <- preprocess_endpoint_def(api_def)
  api_items <- stringr::str_replace_all(x[endpoint_ix], "/v1/", "")
  # GET, /v1/albums/{id}/tracks , Get an album's tracks, tracks*
  c(
    "#' @export"
  )
}